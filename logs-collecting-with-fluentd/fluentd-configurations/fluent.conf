# ------------------------------------------------------------------------------
# Fluentd pipeline (Docker demo)
# Goal:
#   - Ingest JSON log lines from multiple files
#   - Keep:
#       * ERROR logs from namespaces matching ^fnlgr-
#       * INFO  logs from namespace exactly statsvc-env5
#   - Merge all selected events into ONE file.
#
# Notes:
#   - This file is used in a Docker demo to simulate EKS logs.
#   - Namespace is injected by the sample logger as:
#       {"kubernetes":{"namespace_name":"<ns>"}}
# ------------------------------------------------------------------------------

# -----------------------------------
# Source: tail all *.log as JSON-Lines
# -----------------------------------
<source>
  @type tail
  path /fluentd/log/files/*.log
  refresh_interval 5
  pos_file /fluentd/pos/app.pos
  tag app.log
  read_from_head true
  <parse>
    @type json
  </parse>
</source>

# -----------------------------------------------------------
# Step before branches: process Kubernetes annotations
# -----------------------------------------------------------
<match app.log>
  @type relabel
  @label @ANNOTATION_FILTER
</match>

# -----------------------------------------------------------
# Annotation-driven filtering
# -----------------------------------------------------------
<label @ANNOTATION_FILTER>
  # NOTE: Skipping kubernetes_metadata filter since annotations are emulated in app logs

  # Drop logs if annotation log_filter_enabled == "false"
  <filter **>
    @type grep
    <regexp>
      key $.kubernetes.annotations.log_filter_enabled
      pattern /^true$/
    </regexp>
  </filter>

   <filter **>
    @type record_transformer
    enable_ruby true
    <record>
      keep ${(record["level"] =~ Regexp.new(record.dig("kubernetes","annotations","log_level_filter_pattern") || ".*")) ? "true" : "false"}
    </record>
  </filter>

  <filter **>
    @type grep
    <regexp>
      key keep
      pattern true
    </regexp>
  </filter>

  # Forward logs that passed filters to the next stage
  <match **>
    @type relabel
    @label @LOG_ENABLED
  </match>
</label>

# -----------------------------------------------------------
# After annotation filtering, continue pipeline as app.log.filtered
# -----------------------------------------------------------
<label @LOG_ENABLED>
  <match **>
    @type copy
    <store>
      @type relabel
      @label @FNLGR
    </store>
    <store>
      @type relabel
      @label @STATS
    </store>
  </match>
</label>

# ----------------------------------------------
# Branch 1: ERRORs from namespaces /^fnlgr-/
# ----------------------------------------------
<label @FNLGR>
  # Keep only namespaces matching the regex
  <filter **>
    @type grep
    <regexp>
      key $.kubernetes.namespace_name
      pattern ^fnlgr-
    </regexp>
  </filter>

  # Send to the shared merge sink
  <match **>
    @type relabel
    @label @MERGED
  </match>
</label>

# ---------------------------------------------------------------
# Branch 2: INFOs from namespace exactly statsvc-env5
# ---------------------------------------------------------------
<label @STATS>
  # Keep only the exact namespace (string anchor ^...$)
  <filter **>
    @type grep
    <regexp>
      key $.kubernetes.namespace_name
      pattern ^statsvc-env5$
    </regexp>
  </filter>

  # Send to the shared merge sink
  <match **>
    @type relabel
    @label @MERGED
  </match>
</label>

# ------------------------------------------
# Merge sink: write everything into ONE file
# ------------------------------------------
<label @MERGED>
  <match **>
    @type file
    path /output/merged.log
  </match>
</label>
